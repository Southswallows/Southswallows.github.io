---
layout: post
category: 读书
title: Python基础教程
tags: python
---

####基础知识

- 导入模块

		import math
		math.floor(2.9)
	需要再次书写倒入的模块名称＋.函数才能使用
- 使用from模块import函数。就可以直接使用函数
	
		from math import floor
		floor(2.9)
	`建议：使用import形式，会存在函数名冲突的问题`
- 还可以使用变量来引用函数:

		a＝math.floor
		a(2.9)
- str()函数把值转化为合理形式的字符串，repr()函数会创建一个字符串。在表现上的不同是：**打印时候，repr()是带单引号的**
- **＋号**可以进行序列、字符串的连接。
- [42]*5  生成新的序列，原来的序列被重复5次
- [None]*5 生成长度为5的列表。None是内建的，表示这里什么都没有。
- `tuple函数`tuple([1,2,3])，将序列作为参数，转化为元组。

####字符串基本知识

- `x.find(需要找到的字节,a,b)方法`在字符串中寻找，返回最左端的索引。a,b表示搜索位置。
- `x.join()`将字符串链接，每个字符串之间添加。
- `x.lower()`返回字符串的小写
- `x.replace(a,b)`进行替换，a为需要替换的值，b为替换a的值。
- `x.split()`和join相反，将字符串分割成序列。

####字典的方法

- `x.clear()`清除字典中所有的项，无返回值。
- `x.deepcopy()`需要from copy import deepcopy
- `{}.fromkeys(['name','age'])`使用给定的键建立新的字典，默认值为None。
- `x.pop()`将键－值从字典里面删除
- `x.update(a)`利用一个字典更新另外的一个字典。
- 字典生成：

		a = {}
		a[1]='a'
		a[2]=3
		....
####条件循环和其他语句

- 导入模块的时候，使用as，为模块添加别名
	
		import math as fll
		或者from math import sqrt as fll
- 赋值语句  a , b , c = 1, 2 , 3  即给a,b,c赋值1，2，3
- `断言：`用来确保某一条件为真的时候才允许
	
		assert 0<age<100, 'the age must(出现错误的时候添加提示语句)'
- `zip(,)`可以将两个序列压缩在一起，返回一个元组列表。可以用于不等长的序列，当最短的序列用完时停止。
		
		name = ['a', 'b', 'c']
		numbers = [1, 2, 3]
		zip(name,numbers)
	输出：[('a', 1), ('b', 2), ('c', 3)]
- `列表推导式`
	
		[x*x for x in range(10)]
	输出结果为[0,1,4,9,16,25,36,49,64,81]
	还可以结合，if语句，联合使用。
- `pass` 什么都不做，在代码中做占位符使用。
- `del`只负责删除名称，不删除值，python解释器会负责内存的回收。
- def x(*a)  星号将所有值放在同一元组中。
- def x(**a)  星号将收集为字典
- `递归`就是引用自生。
- `多态`对不同类的对象使用同样的操作。**＋符号：**可以连接数字也可以连接字符串。
- class语句中的代码都在特殊的命名空间中，`类命名空间`
- 类的定义其实是执行代码块，类的定义并不是只限于使用`def`
- 查一个类是否是另一个类的子类，使用`issubclass`
- 使用`xxx._bases_`可以获得已知类的基类(也就是超类superclass)
- 一个对象属于哪个类使用`xxxx._class_`

**如何分配处理好类的使用**

1. 将程序需要用刀的名词、动词、形容词写出来
2. 名词可作为类
3. 动词可作为方法
4. 形容词可作为特性
5. 然后将方法和特性分配到类中
6. 考虑类和对象的关系（继承或协作）

----

- `构造方法：`当一个对象被创建后，会立即调用构造方法。类似于：def __init__(self):
- 在继承了超类之后，可以重写超类的方法。
- 如果一个类的构造方法被重写，那么就需要调用超类的构造方法，否则会出错。对于这样的问题，应对的方法有：1.调用超类构造方法的未绑定版本，使用super函数。
- 直接调用类的方法Bird.__init__(self),就没有实例被绑定，就可以自由地提供self参数，叫做`未绑定方法`
- 使用`super()`再子类中才能使用且有效，super(songbird，self).__init__()
- `property函数`创建一个属性


####迭代器

- `-iter-方法`返回一个迭代器，迭代器是具有next方法的对象。调用next方法的时候，迭代器返回下一个值。
- 一个实现了`_iter_`方法的对象是可迭代的，一个实现`next`方法的对象是迭代器

####生成器

- 任何含有`yield`语句的函数称为生成器。
- 生成器可以进行递归～

		try:
    	<...............>   #可能得到异常的语句
		except <.......>:       #锁定是哪种异常
  	  	<...............>   #出现异常的处理方法
  	  	else:
  	  	....               #无异常时候处理
- yield语句意味着生成一个值，return意味着生成器停止执行。
- 生成器被调用时，函数体中的代码不会被执行，返回一个迭代器。每次请求一个值，就会执行生成器中的代码，知道遇到yield或者return
- 生成器由两部分组成：

	- 生成器的函数
	- 生成器的迭代器
	- 生成器函数：是用def定义的包涵yield的部分
	- 迭代器：函数返回的部分

####编写自己的模块

- 任何Python程序都可以作为模块导入
- 需要将python程序保存到一个位置，然后将这位置添加到模块搜索的目录中。

		假如位置为～／python
		import sys
		sys.path.append(完整路径/home/yourusename/python)
- 这样，在后面程序中，就可以导入自己的程序了
		
		例如：import hello
- 模块用来定义函数，类和其他一些内容，经常在其中添加一些检查模块是否正常的测试代码。
- `__name__变量`显示名字，避免有测试程序的模块在导入时候运行：

		if __name__='__main__':
			test()  //模块中有定义test函数
- 让模块可以用的方法

	1. 将模块放在正确的位置
	2. 告诉编译器去哪里找
	3. **将模块放在/Library/Python/2.7/site-packages'里面最好，适当修改文件名。这样所有程序都可以导入 。**
	4. **在PYTHONPATH环境变量中包含 模块所在目录**
			
			export PYTHONPATH ＝ $PYTHONPATH:~/python   //:后面为位置

- `包`必须包含一个__init__.py的文件，直接将模块放置在包的目录内即可。
- 在python交互模式下，获取模块信息的方法

	- `dir函数`查看模块包中包涵的内容**dir(xxx)**
		(以_开始的名字，不是供模块外部使用的，没有太大用处)
			
			进行过滤显示的模块中的内容
			［n for n in dir(xxx) if not n.startswith('_')］
			这样就显示出模块中可以给外部调用的函数
	- `__all__变量`显示模块的公有接口（部分函数没有显示出来）
	
			copy.__all__
	- `help`进行帮助，**help(xxx or xxxx.xxx)**
	- `__doc__文档显示`
	
			print xxx.__doc__
			print xxx.xxx.__doc__
	- `__file__`查找原代码的位置
	
			xxx.__file__
- `heapq模块（堆）`，将列表作为堆对象的本身

		heap为堆名字，即列表的名字
		函数heappush(heap,x)    将x入堆
		函数heappop(heap)     将堆中的最小元素弹出
		函数heapify(heap)     将heap属性强制应用到任意一个列表
		函数heapreplace(heap,x) 将堆中的最小元素弹出，并将x推出
		函数nlargest(n,iter)   返回iter中第n大的元素  （iter为可迭代对象）
		函数nsmallest(n,iter)  返回iter中第n小的元素
- 堆属性：元素排序：位于i位的元素总比i/2位置元素大。
- `双端队列`

		from collections import deque
		q = deque(range(5))
		q = [0,1,2,3,4]
		q.append(5)
		q = [0,1,2,3,4,5]
		q.appendledf(6)
		q = [6,0,1,2,3,4,5]
		q.pop()
		5
		q.popleft()
		6
- `time模块`
- `random模块`	比较有用的函数有：	
	- `random` (0~1的随机数)
	- `uniform(a,b)`（a到b的随机实数，包括a）
	- `randrange(start,stop,step)`(起始，步数给定的随机数)
	- `choice(seq)`（在序列seq中随机选择的数）
	- `sample(seq,b)`（在序列seq中选者n个随机的数
－ `shelve模块`
- `re模块`包涵对正则表达式的支持