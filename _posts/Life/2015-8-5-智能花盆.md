---
layout: post
title: 智能花盆中zigbee(Fujitsu)
category: life
tags: 
keywords: 
description: 
---

- 使用的开发板：STM32F103开发板、STM32F407开发板
- zigbee开发板：七星虫CC2530 zigbee开发套件(包括调试器在内，可二次开发)
- 软件IAR embedded workbench（810）
- iar的版本和协议栈的版本是配对的，基于这个zstack-251a版本的协议栈
- smartrf programmer软件的功能，将hex文件烧录进cc2530芯片中
- cc2530bb模块，cc2530仿真器

----

###CC2530情况
- CC2530完全兼容8051内核，支持IEEE802.15.4协议的无线射频单片机
- 有三个不同的存储访问总线:
    - 特殊功能寄存器（SFR）
    - 数据（DATA）
    - 代码/外部数据（CORE/XDATA）
- 使用单周期访问SFR、DATA和主SRAM。当cc2530处于空闲模式时，任何中断可以把cc2530恢复到主动模式。某些中断能将cc2530从睡眠模式唤醒。
- 系统核心存储器交叉开关使用SFR总线将CPU、DMA控制器和物理存储器和所有的外接设备连接起来
- CC2530的flash容量有32、64、128、256kb（为在线可编程非易失性存储器，并且映射到代码和外部数据存储器空间，还允许应用程序保存必要的数据，以保证这些数据在设备重启后可用。这样可用保存具体网络参数，当系统再次上电后就可以直接加入网络中）

###天线
- 天线主要用来辐射或接受电磁波，一种导行波与自由空间波之间的转换器件。
- 表征天线的参数：方向图、输入阻抗、驻波系数、增益、带宽、极化等
- **输入阻抗：**天线的输入端电压与输入端电流的比值（表示了天线和发射机或接收机的匹配状况）
- **驻波系数：**表征天线与馈线匹配状况。可用来计算从天线反射回发射机或接收机的功率
- **增益：**表征天线集中辐射的程度
- **带宽：**电性能下降到容许值的频率范围。驻波带宽、方向图带宽、圆极化轴比带宽
- **极化：**描述天线辐射电磁波矢量空间指向的参数
- 用途分：通信天线、广播天线、雷达天线
- 原理分：线天线、口径天线、阵列天线
- zigbee天线一般使用：**偶极子、单极子、倒F天线**
- 可用的天线为**倒F天线、折叠偶极子天线**

###IAR embedded workbench
- C交叉编译器，嵌入式应用开发工具
- 支持至少35种8位、16位、32位arm微处理器结构
- 新建工程、新建源文件、project添加源文件
- 调试debug阶段，点击键盘上F11键即可实现程序的单步调试


###基本实验流程
- iar软件的workspace文件后缀为xxx.eww
- 打开软件、加载工程文件
- project Rebuild All
- 然后点击debug按钮，debug之后出现调试工具条，程序停留在main函数处
- 这时候仿真器可以不用，和开发板分离
- 点击开发板上的复位按钮， 烧录的程序开始运行

**可以编译生成hex文件，此文件可以通过Flash Programmer软件烧进cc2530芯片中**

###zigbee协议栈说明

![协议栈](http://7xkeeu.com1.z0.glb.clouddn.com/zigbee.png)

- **Components：**存放放库文件，存放ZDO，driver，hal，zcl等库的代码
- **Documents：**存放TI的开发文档
- **Projects：**存放TI协议栈的例子程序，一个个例子程序都是以一个个project的形式给我们的，学好这些例子程序里面的一两个，基本你能做事情了。 
- **Tools：** 存放TI的例子程序一些上位机之类，作为工具使用。
- zigbee组网的方式：广播、单播、组播
- 分为**协调器**（总节点）和**终端模块**（子节点）
- **协调器**一般以广播的模式，**终端模块**一般为单播模式（向协调器单独发送数据）
- `IEEE802.15.4`仅仅定义了`物理层（PHY）`和`介质访问控制层（MAC）`的数据传输规范，`zigbee协议`定义了`网络层`，`应用程序支持子层`以及应用层的数据传输规范。
- `物理层PYH`包括：`同步头（SHR，Synchronization Header）`、`物理层头（PHR，PHY Header）`、`物理层净荷（PHY Payload）`（同步头主要用于接收端的时钟同步，物理层包含了数据帧的长度信息，物理层净荷有上层提供，包含接收端所需的数据或者命令信息）
- 介质访问控制层`（MAC）`帧包括:`MAC头（MHR，MAC Header）`、`MAC净荷（MAC Payload）`、`MAC尾（MFR，MAC Footer）`（MAC头主要包含地址信息和安全信息；MAC净荷包含了数据或者命令，其数据长度是可变化的；MAC尾包含了数据校验信息）

###协议和协议栈

- **协议**定义的是一系列的通信标准，通信双发需要共同按照这以标准进行正常的数据收发。
- **协议栈**是协议的具体实现形式，用代码实现的函数库，便于调用的代码
- `IEEE802.15.4`仅仅定义了`物理层（PHY）`和`介质访问控制层（MAC）`的数据传输规范，`zigbee协议`定义了`网络层`，`安全层`以及`应用层的技术规范`。
- **协议栈**将各层定义的协议都集合在一起，一函数的形式实现，并给用户提供一些应用层api供用户调用。
- 协议是统一的，各厂商提供的协议栈是有区别的


###无线通信实验

####实验1、2（LED的点亮）
- 首先协调器LED3灯先亮--表示简历了无线zigbee网络
- 随后终端的LED3灯也亮起来--表示加入了无线zigbee网络，协调器和终端组网成功
- 终端模块按键触发，发送数据给协调器，协调器根据收到的数据，进行处理，在协调器上做相应处理（LED的闪烁）

###OSAL（操作系统抽象层）

- Z-Stack1.4.3及以后的版本中引入了一个OSAL(Operating System Abstraction Layer 操作系统抽象层)，整个的协议栈都要在OS的基础上才能运行。利用OS把Z-Stack软件组件从特殊的处理过程相分离，并将软件成分保护了起来。
- 它提供了如下的管理功能：
    - 任务的注册、初始化、开始
    - 任务间的消息交换
    - 任务同步
    - 中断处理
    - 时间管理
    - 内存分配
- 在ZigBee协议中，协议本身已经定义了大部分内容。在基于ZigBee协议的应用开发中，用户只需要实现应用程序框架即可。从ZigBee的协议架构图中我们也可以看到，其中的应用程序框架中包含了最多的240个应用程序对象，如果我们把一个应用程序对象看做为一个任务的话，那么应用程序框架将包含一个支持多任务的资源分配机制。于是OSAL便有了存在的必要性，它正是Z-Stack为了实现这样一个机制而存在的。
- OSAL主要是这样一种机制,一种任务分配资源的机制,从而形成了一个简单多任务的操作系统。首先,osal初始化系统，包括软件系统初始化和资源初始化．其中软件系统初始化就是初始化一些变量，比如osal重要的组成部分任务表，任务结构体和序列号．资源初始化主要包括内存，中断，ＮＶ等各种设备模块资源．这就和我们嵌入式系统中的RTOS操作系统μC/OS-II有了很大的相似处。μC/OS-II中也是通过建立任务把一个问题进行分解，任务之间可以通过消息队列的方式进行通信。
- osal通过osal_add_task添加任务到任务表中，形成一个任务链表。这个任务链表是以任务的优先级先后排序的。优先级高的排在前，低者排于后。
- 最后，开始运行系统，系统是以一个死循环的形式工作的(死循环存在于osal_start_system()这个函数中)在循环体当中不断地检测各个任务，看是否要运行等．这就相当于我们平时用的linux和window等多任务系统，把ＣＰＵ分成Ｎ个时间片（有多少任务就分成多少时间片），只要处理频率高，就相当于多任务同时运行了
- OSAL实现了类似操作系统的某些功能，但我认为并不能称之为真正意义上的操作系统。它的复杂性和功能性和通常的操作系统都有所不同。OSAL层是与协议栈独立的，但是整个协议都要基于OS才能运行。
- **通过tasksEvents指针访问事件表的每一项，如果有事件发生，则查找函数表找到时间处理函数进行处理，处理完后，继续访问事件表，查看是否有事件发生，无限循环。**
- **事件表使用数组来实现，数组的每一项对应一个任务事件，每一位表示一个事件。**
- **函数表使用函数指针数组来实现，数组的每一项是一个函数指针，指向了事件处理函数。**
- **基于事件驱动的轮询式操作系统**

####以key为例子讲述key消息被处理的过程

- 首先在key初始化过程中会调用osal_start_timerEX(Hal_TaskID,HAL_KEY_EVENT,HAL_KEY_POLLING_VALUE),此语句的功能就是将检测key的事件放入Time事件链表。此事件隶属Hal_Task,Timeout是HAL_KEY_POLLING_VALUE。
- 当1ms心跳来临时，判断timeout是否小于1，如果不小于1，timeout=timeout-1，并等待下一次心跳。
- 如果小于1，则发出HAL_KEY_EVENT这个消息到消息队列中，然后调用Hal_Task的事件来处理函数Hal_ProcessEvent()处理HAL_KEY_EVENT消息
- 在处理这个消息的过程中，调用函数HallKeyPoll().这个函数检测当前有无按键，如果有按键并且和上次按键值不同，则认为有新的按键按下，并发出相应的按键消息。
- 上述过程中，必须通过osal_start_timerEx()函数，这个函数将key检测事件继续放入Timer事件链表，以便后面心跳时能检测到该事件，就是说在每100ms都会扫描看有无按键按下。



####关于c语言内容
- extern 用来声明外部函数，外部函数的实现代码存在其他文件中
- 数据发送函数：`afStatus_t AF_DataRequest()`
           
         里面的参数：
        afAddrType_t *dstAddr,
        endPointDesc_t *srcEP,
        uint16 cID,
        uint16 len,
        uint8 *buf,
        uint8 *transID,
        uint8 options,
        uint8 radius
        其中最重要的两个参数是：uint16 len,uint8 *buf,
        一个是发送数据的长度，一个是存放发送数据的缓冲区的指针
        afAddrType_t *dstAddr--包含了目的节点的网络地址以及发送数据的格式（如广播、单播、多播）
        endPointDesc_t *srcEP--在zigbee无线网络中，通过网络地址可以找到某个具体的节点，网络地址确定节点，每个节点上最多支持240个端口
        uint16 cID--描述的是命令号，主要用来标实不同的控制操作，不同的命令号代表了不同的控制命令。（如终端节点在发送数据时，使用的命令ID为GENERICAPP_CLUSTERID，这个宏定义在Corrdinator.h文件中。）
        uint8 *transID--是一个指向发送序号的指针，每次发送数据时，发送序号会自动+1


- 节点描述符`GenericApp_epDesc`
- 任务优先级`GenericApp_TaskID`
- 数据发送序列号`GenericApp_TransID`
- `afRegister()`将节点描述符进行注册，只有注册了才能使用OSAL提供的系统服务
- `osal_msg_deallocate`函数将其占据的的堆内存释放，以免引起“内存泄露”
- `GenericApp_NwkState = DEV_INIT`表示把设备状态初始化为DEV_INIT，表示该节点没有连接到Zigbee网络。（设置为`DEV_END_DEVICE`，即为终端节点）
- 在zigbee网络中，协调器的网络地址是固定的，为`0x0000`。在向协调器发送时，可以直接指定协调器的网络地址。
- **Tool文件夹下面的文件**
    - `f8w2530.xcl`包含了cc2530单片机的链接控制指令（如定义堆栈大小、内存分配等）
    - `f8wConfig.cfg`包含了信道选择、网络号等有关的链接命令
    - `f8wCoord.cfg` 定义了设备类型，定义设备具有协调器和路由器功能。
    - `f8wRouter.cfg`和上面的类似**DRTR_NWK** 定义该设备为路由器；**DZDO_COORDINATOR**定义为协调器
- `HAL_EXIT_CRITICAL_SECTION`关中断--也可以恢复中断